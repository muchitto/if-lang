 // a programming language for interactive fiction
extern def print(text : string) -> void


new Door called OldBrokenDoor {
    name = "broken old door"
    description = "A broken old door"  
    
    def hitWith(with : Thing) -> bool {
        if !super.hitWith(with) {
            return false
        }

        print "You hit the door with " + with.name + "."
        print "The door breaks into thousand moldy"

        return true
    }
}

new type Thing called Container {
    var horror : string    
}

enum Type {
    TestItem1,
    TestItem2
}

var test : Test

// Correct one
//var testjoo = []
var test2 : { test22 : Test, perse : number[], haha : { kaasu: string} } = { 
    test22 : test, 
    perse : [], 
    haha : {
        kaasu: ""
    } 
}
//var test3 : { test : Test, perse : number[] } = { test : test, perse : [] }

var test5 : Type = .Test

// Incorrect one
// var test3 : { test : Test, perse : number[] } = { test : test, perse : 100 }

var currentRoom : Room

new Room called Verb {
    var synonyms : string[]
}

new type Jorma {
    var test : Test
    var perse : int
}

// a new type called Thing as the base type for all objects
new type Thing {
    var name : string
    var description : string
    var is_fixed_in_place : bool = false

    @verb "look", "[this]"
    def look() -> bool {
        print(description)

        return true
    }
    
    @verb "place", "[something]", "in", "[this]"
    def place() -> bool {
        if this is object {
            print("You can't place " + something.name + " in " + name + ".")
            return false
        }

        print("You place " + something.name + " in " + name + ".")
        return true
    }
   
    @verb "hit", "[this]", "with", "[with]"
    def hitWith(with : Thing) -> bool {
        print("You hit " + name + " with " + with.name + ".")
        return true
    }

    @verb "take", "[this]"
    def take() -> bool {
        if is_fixed_in_place {
            print("You can't take " + name + " it is fixed in place.")
            return false
        }

        print("You take " + name + ".")
        return true
    }
}

enum LightState {
    On,
    Off
}

new type Thing called Room {
    var light : LightState = .On
}

new Room called DarkForest {
    name = "dark forest"
    description = "A dark forest"
    light = .Off
}

// because we don't say new typ, it will be a new type AND a new instance of that type both called Door
new Thing called Door {
    @verb "open", "[this]"
    def open() {
        print("You open the door.")
    }

    @verb "hit", "[this]", "with", "[with]"
    def hitWith(with : object) -> bool {
        if currentRoom.light == .Off {
            print("You can't see the door.")
            return false
        }

        print("You hit the door with " + with.name + ".")
        return true
    }
}


new object called Test {
    var test : Test
    var perse : number

    def init() {

    }

    def test2() {
        test.test.test.test.perse = 100
        test = test

        test = null
        test.test = null
        test.test.test = null

        var haha = Test
    }   
}
















    /*
    ass()
    
    def ass() {
    }
    
    return true
    */

/*

// You can import other files with the import keyword
import thing from "./thing"

// You can define a global variable
var x = 1

// You can define a function in the global scope
 
// You can create a new object type, which is not instanced immediately
type object verbSomething {}

@verbRule "shoot" verbSomething
new verb Shoot with name "Shoot", is container  {
    def test() {
        if p + 2 * 10 {
            print("YES")
        }

        var test = test[0]["gheaha"]
        var kusi = test.hahmo.thing

        print("YES")
    }
} 

// new creates and instantiates a new object
// first comes the parent object, then the name of the new object
// attribute is a builtin object type which inherits from object, it is nothing special
// object is the root object type of the language
new object Thing {
    name "thing"
    description "A thing" 
    light is on
    container false
        
    @verb `hit [this]`, "hegaha"
    def Hit {
        if light on {
            print "You hit the thing."

            return true
        }

        print "You can't see the thing."
        return false
    }

    // @ denotes a decorator and is used to add metadata to a function or class
    // the decorator can have arguments separated by spaces or commas
    @verb `look [this]` "gahaea"
    def Look {
        if light on {
            print "You see the thing."
            return true
        }

        print "You can't see the thing."
        return false
    }

    @verb `hit [this] with [with]`
    def HitWith(with2 : object) {
        return false
    }
}

*/